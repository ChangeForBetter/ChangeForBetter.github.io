<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ssh 公钥认证原理小记]]></title>
    <url>%2F2018%2F02%2F08%2Fdevops%2Fssh%2F</url>
    <content type="text"><![CDATA[两大类加密方法 单钥加密, 对称加密(private key cryptography)加密和解密都用同一套密码密钥的保存十分重要, 密钥泄漏则密码泄漏(不安全) 双钥加密, 非对称加密(public key cryptography)加密和解密用的是两套密码(公钥 + 私钥)公钥用来加密信息, 私钥用来数字签名公钥可以解密私钥加密信息, 反之亦然同时生成公钥和私钥相对比较容易(ssh-keygen)从公钥推算出私钥, 应该是很困难或者是不可能的(安全) 数字签名和数字证书参考公钥/私钥 加密解密过程 数字签名(digital signature)用来校验信息是否被篡改私钥端生成数字签名, 将数字签名+原信息一起发送 $信息摘要digest = hash(message)$, hash一下缩短待校验信息长度$signature = 私钥加密(digest)$ 公钥端校验数字签名 $hash(message) == 公钥解密(signature)?$ 数字证书(digital certificate)用来防止中间人攻击(公钥被替换), 由第三方权威安全CA机构(绝对安全)管理私钥端用CA私钥加密公钥生成数字证书, 将数字签名+原信息+数字证书一起发送 $certificate = CA私钥加密(公钥 + 公钥所属机构信息 + 其他)$ 公钥端用CA公钥解密证书得到公钥, 再校验数字签名 $公钥 = CA公钥解密(数字证书)$$hash(message) == 公钥解密(signature)?$ ssh公钥指纹 ssh第一次登陆主机，会出现上面的提示；意思是无法确认远程主机是否真实(是否是中间人攻击者的主机)，请先确认下公钥指纹是否正确；公钥指纹(Togx2KzxWt4xcGSIX8K1QA2voDxk5iZEabEEJRxIXpc)则是对远程主机公钥进行hash运算得到(减少校验长度)；正确的公钥指纹需要远程主机贴出，方便用户核对；确认公钥指纹后，会将远程主机的公钥保存到本地的~/.ssh/known_hosts中，下次进行连接的时候会直接使用公钥进行信息加密 公钥免密码登录原理 登录的时候，远程主机会用随机向用户发送一段字符串 用户使用私钥将发送的字符串加密后返回给远程主机 远程主机使用事先存储的公钥解密信息(~/.ssh/authorized_keys)，如果解密并核对成功，则证明用户可信，用户可直接登录，不用输入密码 公钥免密码登录远程主机 生成公钥对 123456# -t: 以 rsa 算法加密# -P: 登录密码为空(免密码登录)# -C: 注释信息, 一般是个人邮箱# 公钥: ~/.ssh/id_rsa.pub# 私钥: ~/.ssh/id_rsassh-keygen -t rsa -P '' -C "your email" 向远程主机添加可信任公钥 12# 会将公钥信息加入到远程主机 ~/.ssh/authorized_keys 中ssh-copy-id ~/.ssh/id_rsa.pub user@host 远程主机需要支持公钥免密码登录(/etc/ssh/sshd_config) 123RSAAuthentication yesPubkeyAuthentication yesAuthorizedKeysFile .ssh/authorized_keys 参考 公钥/私钥加密解密过程 SSH远程登录原理]]></content>
      <categories>
        <category>devops</category>
      </categories>
      <tags>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法小结(Python实现)]]></title>
    <url>%2F2017%2F12%2F13%2Falgorithm%2Fsort%2F</url>
    <content type="text"><![CDATA[冒泡排序 12345678910111213141516171819202122'''1.相邻两个数进行比较, 将较大的数往后移动, 一趟循环后最大的数在最后面2.重复1(每次除去最后一个元素), 最多 n-1 趟3.一趟比较下来如果没有发生交换说明数列已经有序'''def bubble_sort(l, reverse=False): length = len(l) exchanged = True # 最多 length-1 趟排序, 每次排序将较大(小)的排在最后 for end in range(length-1, 0, -1): if exchanged: # print "------------" exchanged = False for i in range(end): # 相邻数之间进行交换 if (l[i] &gt; l[i+1]) ^ reverse: l[i], l[i+1] = l[i+1], l[i] exchanged = True # print l else: break return l 直接插入排序 1234567891011121314151617'''将一个数插入到已经排好序的有序列表中, 从而得到新的有序列表'''def insert_sort(l, reverse=False): length = len(l) # 将第i个数向前找到合适的位置插入 for i in range(1, length): # temp记录当前要插入的值 temp = l[i] # 找到第i个数在前i个数中的位置 j = i - 1 # 若前面的数比l[i]大, 说明前面的数要往后移动 while j &gt;= 0 and (l[j] &gt; temp) ^ reverse: l[j+1] = l[j] j -= 1 l[j+1] = temp return l 希尔排序(直接插入排序改良) 假设有这样一组数[13, 14, 94, 33, 82, 25, 59, 94, 65, 23, 45, 27, 73, 25, 39, 10], 如果以步长为5开始进行排序, 可以通过将这列表放在有5列的表中来更好地描述算法, 这样他们就应该看起来是这样:123413 14 94 33 8225 59 94 65 2345 27 73 25 3910 然后我们对每列进行排序:123410 14 73 25 2313 27 94 33 3925 59 94 65 8245 将上述四行数字, 依序接在一起: [10, 14, 73, 25, 23, 13, 27, 94, 33, 39, 25, 59, 94, 65, 82, 45], 然后再以3为步长进行排序:12345610 14 7325 23 1327 94 3339 25 5994 65 8245 排序之后变为:12345610 14 1325 23 3327 25 5939 65 7345 94 8294 最后以1步长进行排序(此时即为直接插入排序) 123456789101112131415161718'''每次对相隔 gap 的数组成的列表进行插入排序需要保证最后一次 gap 为 1 (直接插入排序)减少插入排序交换次数(gap 大时交换间隔大, 交换操作时间 &gt; 循环操作时间)'''def shell_sort(l, reverse=False): length = len(l) gap = length // 2 while gap &gt; 0: for i in range(gap, length): temp = l[i] j = i - gap while j &gt;=0 and (l[j] &gt; temp) ^ reverse: l[j+gap] = l[j] j -= gap l[j+gap] = temp gap //= 2 return l 选择排序 123456789101112131415'''从第 i 个数开始, 与后面的 n-i 个数作比较, 找到最小的数与第 i 个数进行交换'''def selection_sort(l, reverse=False): length = len(l) for i in range(length-1): min_index = i for j in range(i+1, length): if (l[j] &lt; l[min_index]) ^ reverse: min_index = j # 后面有比 i 小的数, 进行交换 if min_index != i: l[i], l[min_index] = l[min_index], l[i] # print l return l 堆排序(保存比较结果, 减少重复比较次数) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950'''选择排序一趟循环下来没有保存比较结果; 后续会有重复比较, 堆保留比较结果, 减少重复比较次数大(小)顶堆: 每个结点的值都大(小)于或等于其左右孩子结点的值的完全二叉树.、完全二叉树结点i: 左孩子: 2*i + 1 右孩子: 2*i + 2 父节点: (i-1) // 2大顶堆调整: 父结点跟孩子结点比较 孩子结点大: 父结点与孩子结点交换, 孩子结点继续与孙子结点比较 父结点大: 不做调整过程: 1.初始化大顶堆(从编号最大的非叶子结点往前到根结点依次进行大顶堆的调整) 2.数列首尾交换(最大的数移到了最后面) 3.剩下的数进行大顶堆调整 4.重复2,3到只剩下1个数'''def heap_sort(l, reverse=False): # 大顶堆调整 def heap_adjust(start, end): root = start child = 2*root + 1 while child &lt;= end: max_node = root # 左孩子大 if (l[child] &gt; l[max_node]) ^ reverse: max_node = child # 右孩子大 if child + 1 &lt;= end and (l[child+1] &gt; l[max_node]) ^ reverse: max_node = child + 1 # 当前根结点不是最大的, 根和孩子有交换, 孩子结点要继续跟孙子作调整(如果有孙子) if max_node != root: l[root], l[max_node] = l[max_node], l[root] print l root = max_node child = 2*root + 1 # 当前堆已经是大顶堆 else: break length = len(l) # 初始化大顶堆: 从编号最大的非叶子结点往前到根结点依次进行大顶堆的调整 for start in range(length//2-1, -1, -1): heap_adjust(start, length-1) # 堆排序, 首尾元素交换, 然后进行大顶堆调整 for end in range(length-1, 0, -1): l[0], l[end] = l[end], l[0] heap_adjust(0, end-1) return l 快速排序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546'''1.选取关键数(一般是数列第一个)2.一趟排序后, 依据关键数将数列分成独立的两部份数列; 左边的 &lt;= 关键数, 右边的 &gt;= 关键数3.对左右两部份数列重复1,2'''# 简易版, 费内存def quick_sort(l, reverse=False): if len(l) &lt;= 1: return l lesser, greater = [], [] pivot_key = l[0] for item in l[1:]: if (item &lt; pivot_key) ^ reverse: lesser.append(item) else: greater.append(item) # print lesser, pivot_key, greater return quick_sort(lesser, reverse) + [pivot_key] + quick_sort(greater, reverse)def quick_sort(l, left, right, reverse=False): if left &gt;= right: return l# ------------- partition ------------------- low, high = left, right pivotkey = l[low] # 找到 pivotkey 排序后在数列中的索引 while low &lt; high: while low &lt; high: if (pivotkey &lt; l[high]) ^ reverse: high -= 1 else: l[low], l[high] = l[high], l[low] low += 1 break while low &lt; high: if (pivotkey &gt; l[low]) ^ reverse: low += 1 else: l[low], l[high] = l[high], l[low] high -= 1 break # print l, pivotkey# ------------------------------------------- quick_sort(l, left, low-1, reverse) quick_sort(l, low+1, right, reverse) return l 基数排序 12345678910111213141516171819202122232425262728'''原理: 1.从低阶到高阶, 依次比较每个数相同阶对应的数 2.数列必须是整数, 或者能转换为整数过程: 1.找到最大的数, 根据其位数k决定要循环次数(若预先知道k可减少一次数列的遍历) 2.依次依据数列中的每个数的第k位(低位到高位)的数, 将其加入到对应桶中 3.低位到高位遍桶重组新数列(此时的数列已经按照第k位的数排好序) 4.循环步骤2,3 k次'''import mathdef radix_sort(l, radix=10): ''' l为整数列表, radix为基数 ''' # 计算出数列中最大数的位数 k = int(math.ceil(math.log(max(a)+1, radix))) bucket = [[] for i in range(radix)] for i in range(k): # k次循环 for val in a: # 获得整数第 i 位数字(地位到高位, 最低位为0) val_k = val // (radix**i) % radix bucket[val_k].append(val) del l[:] # 清空列表l for each in bucket: l.extend(each) # 桶合并 # print l, i bucket = [[] for i in range(radix)] 归并排序 12345678910111213141516171819202122232425262728293031323334353637383940'''二路归并思想: 两个数列各自已经排好序, 分别取出最小的元素到一个序列中过程: 1.将数列均分为两个子数列 2.对两个子数列进行排序 3.将排序好的两个子数列归并可以作为外部排序思路'''def merge(left, right, reverse=False): ''' 合并数列left, right(left, right各自有序), 返回新数列result ''' len_left, len_right = len(left), len(right) result, i, j = [], 0, 0 # 将left, right中较小(大)的依次合并到result while i &lt; len_left and j &lt; len_right: if (left[i] &lt; right[j]) ^ reverse: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 # left已经全部合并到result if i == len_left: result.extend(right[j:len_right]) # right已经全部合并到result else: result.extend(left[i:len_left]) # print left, right, result return resultdef merge_sort(l, reverse=False): length = len(l) if length &lt;= 1: return l # 二路归并分组 mid = length // 2 left, right = merge_sort(l[:mid], reverse), merge_sort(l[mid:], reverse) return merge(left, right, reverse) 时间复杂度和空间复杂度 参考 基数排序 归并排序]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模式匹配算法 KMP]]></title>
    <url>%2F2017%2F12%2F06%2Falgorithm%2FKMP%2F</url>
    <content type="text"><![CDATA[问题描述 在主字符串string(abcabcabx)中找到匹配到子串pattern(abcabx),返回pattern在string中的index暴力匹配时间复杂度O(m*n), KMP时间复杂度O(m+n) 最长相同前后缀, next 数组next[i] = pattern 前 i+1 个字符的最长相同前后缀长度 pattern对应index 字符串 最长相同前后缀 最长相同前后缀长度 0 a 不存在 0 1 ab 不存在 0 2 abc 不存在 0 3 abca a 1 4 abcab ab 2 5 abcabx 不存在 0 123char: | a | b | c | a | b | x |index: | 0 | 1 | 2 | 3 | 4 | 5 |value: | 0 | 0 | 0 | 1 | 2 | 0 | 所以abcabx的next数组为:[0, 0, 0, 1, 2, 0] 使用 next 数组(KMP算法) 要点: 保持 i 不会回溯 next[j]保存的是 pattern 前 j+1 个字符的最长相同前后缀长度 string[i] != pattern[j], string[i] 可跳过 pattern 前 next[j-1] 个字符进行比较 过程:string[i] == pattern[j]时, ++i, ++jstring[i] != pattern[j]时, j == 0;i 往后移动, 即: ++i j != 0;可保持 i 不动, 跳过 string[i] 与 pattern 前 next[j-1] 个字符做比较, 减少比较次数, 即: j = next[j-1]直接比较 string[i] 和 pattern[j] 1.string[i] == pattern[j], ++i, ++j i 5 string a b c a b c a b x pattern a b c a b x j 2 4 5 2.string[5] != pattern[5]3.next[4] = 2, 即: 保持 i 不动, 跳过 pattern 前 2 个字符, 比较 string[5] 和 pattern[2] i 5 string a b c a b c a b x pattern a b c a b x j 2 Python实现next 数组12345678910111213141516171819def get_next(pattern): length = len(pattern) next_array = [0] * length prefix, suffix = 0, 1 while suffix &lt; length: # pattern[prefix]: 前缀字符 # pattern[suffix]: 后缀字符 if pattern[suffix] == pattern[prefix]: prefix += 1 # next_array[i] = pattern 前 i+1 个字符的最长相同前后缀长度 next_array[suffix] = prefix suffix += 1 # 当前位置的 pattern 没有最长前后缀, 长度为初始化的 0 elif prefix == 0: suffix += 1 # 类似在后缀中匹配前缀 else: prefix = next_array[prefix-1] return next_array KMP算法1234567891011121314151617181920def index_kmp(string, pattern, pos=0): i, j = pos, 0 len_string, len_pattern = len(string), len(pattern) next_array = get_next(pattern) # print next_array while i &lt; len_string and j &lt; len_pattern: # print string[:i + 1] # print " " * (i - j) + pattern[:j + 1] # print "-" * len_string if string[i] == pattern[j]: i += 1 j += 1 elif j == 0: i += 1 else: j = next_array[j-1] if j == len_pattern: return i - len_pattern else: return 参考链接前后缀KMP匹配过程next数组]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 部署到 GitHubPages]]></title>
    <url>%2F2017%2F12%2F01%2Fhexo%2FGitHubPages%2F</url>
    <content type="text"><![CDATA[背景: GitHubPages 可以免费托管静态文件, 而且自带 cdn 加速 托管到 GitHubPages 不用自己倒腾服务器, 让自己更专注于写博客 创建 github 仓库GitHub Pages 读取的仓库是YOUR-USERNAME.github.io所以仓库名必须是YOUR-USERNAME.github.io 部署 hexo 到 GitHubPages hexo 安装 hexo-deployer-gitnpm install hexo-deployer-git --save 配置 hexo 12345deploy: type: git repo: [repository url] # github 仓库地址 branch: [branch] # 分支名称(master) message: [message] # 自定义提交信息, 默认是 Site updated: &#123;&#123; now('YYYY-MM-DD HH:mm:ss') &#125;&#125; 部署 hexo 到 GitHubPageshexo clean # 清除缓存和之前生成的静态文件hexo deploy --setup # 上传到静态文件github hexo 会以~/.gitconfig里面配置的user.name和user.email作为提交人身份信息 第一次部署时会要求输入github用户名和密码, 后续不用再输入 部署成功后可直接用过YOUR-USERNAME.github.io访问hexo, 因为GitHubPages会强制升级成https, 所以next不支持https的相关功能会失效(比如百度分享) 绑定个人域名 购买域名 YOUR-USERNAME.github.io绑定个人域名 配置完后会在仓库根目录生成一个CNAME文件, 文件内容为绑定的个人域名 只能绑定一个个人域名 hexo部署时默认不会生成CNAME文件, 可在 hexosource目录下添加CNAME文件, hexo deploy会将其加入到public目录中 README.md hexo部署时默认不会有README.md, 可在source目录下创建并且编辑README.md hexo默认会将source目录下的所有md文件渲染成成html文件, 需要配置hexo不要对README.md进行渲染12skip_render: # 不要对 README.md 进行渲染 - README.md 个人域名配置域名解析CNAME 记录类型 主机记录 记录值 CNAME www YOUR-USERNAME.github.io CNAME @ YOUR-USERNAME.github.io]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo + next 搭建个人博客]]></title>
    <url>%2F2017%2F11%2F27%2Fhexo%2Fhexo%2F</url>
    <content type="text"><![CDATA[hexo安装需要预先安装 git 和 nodenode二进制文件下载链接: https://nodejs.org/dist/latest/node二进制可执行压缩包解压后需要将bin目录全路径加入环境变量PATH中1234567891011121314# 解压 node 二进制压缩包tar -zxvf node-v9.2.0-linux-x64.tar.gz -C /usr/local/mv /usr/local/node-v9.2.0-linux-x64 /usr/local/nodejs# 添加环境变量 PATH 添加 node bin 目录全路径vi ~/.bashrcexport NODE_BIN="/usr/local/nodejs/bin"export PATH=$PATH:$&#123;NODE_BIN&#125;# 使环境变量生效source ~/.bashrc# 安装 hexo; npm 默认在 node bin 目录中npm install -g hexo-cli hexo基本命令 建站hexo init &lt;hexo-folder&gt;cd &lt;hexo-folder&gt;npm install 添加标签页/分类页hexo new page tags/categories默认没有标签页/分类页生成 page 后需要配置 md 属性, type: tags/categories 列出资源文件信息(post/page/tag/category)hexo list post 生成静态文件(文件存放在public目录)hexo generate 启动 hexohexo server -p 80 -s -l hexo配置(_config.yml)123456title: SkyLiu # 网站标题subtitle: # 网站副标题description: "厚德博学，崇实去浮。" # 网站描述author: SkyLiu # 名字language: zh-Hans # 语言timezone: Asia/Shanghai # 时区 使用next主题 下载 next 到 theme 目录下cd &lt;hexo-folder&gt;git clone https://github.com/iissnan/hexo-theme-next themes/next 配置 hexo _config.ymltheme: next # 主题, 默认是landscape next主题配置(_config.yml)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788# next 主题配置# https://github.com/iissnan/hexo-theme-next/blob/master/README.cn.mdscheme: Pisces # Muse(默认) | Mist | Pisces | Gemini# 设置菜单# fa 图标名称搜索: https://www.thinkcmf.com/font/search/index.html# 搜出来的名字去掉前缀 fa-# http://theme-next.iissnan.com/getting-started.html#menu-settings# name: 访问地址 || Font Awesome 图标名称# name 对应不同语言显示的名字在 next 的 languages/语言.yml 中(languages/zh-Hans.yml)menu: home: / || home # 首页 about: /about/ || user # 关于(默认没有) tags: /tags/ || tags # 标签(默认没有) categories: /categories/ || th # 分类(默认没有) archives: /archives/ || archive # 归档 comments: /comments/ || comments # 留言板(自定义)menu_icons: enable: true # 显示 fa 图标# 侧边栏社交信息# http://theme-next.iissnan.com/theme-settings.html#author-sites# 显示名字: 链接 || Font Awesome 图标名称social: GitHub: your github || github 新浪微博: your weibo || weibosocial_icons: enable: ture # 是否线显示 fa 图标 icons_only: false # 是否只显示图标, 不显示名字 transition: false # 改了跟没改看不出什么区别links_title: 友情链接links_layout: block # block(横铺) | inline(纵铺)links:# 显示名字: 链接 知乎: https://www.zhihu.com/ 百度: https://www.baidu.com/# 侧边栏(Pisces方案)sidebar: position: left # 侧边栏位置 left | right offset: 12 # 侧边栏和菜单栏间隔像素值 b2t: true # 置顶图标是否在侧边栏显示 scrollpercent: true # 置顶图标下面是否显示滚屏百分比# 文章目录toc: enable: true number: true # 文章目录是否带数字编号 wrap: true # 小标题过长是否换行显示# 阅读全文# 三种方式: http://www.jianshu.com/p/78c218f9d1e7# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.# 建议在显示概要后面加上&lt;!-- more --&gt;, 不影响文章显示结构auto_excerpt: enable: false # 在主页显示的时候, 是否默认在页面150字数位置截断 length: 150motion: enable: true # 是否以动画形式加载页面(可配置成 false 加速页面显示) async: true # 是否异步加载多个板块post_meta: item_text: true created_at: true # 是否显示发表于 updated_at: true # 是否显示更新于 categories: true # 是否显示分类# 字体显示font: codes: external: true family: Mono # 代码块字体格式为Mono size: 10 # 字体大小# 设置代码高亮# http://theme-next.iissnan.com/theme-settings.html#syntax-highlight-schemehighlight_theme: normal # normal | night | night blue | night bright | night eightiesfooter: since: 2017 # 博客起始年份 theme: version: false # 不显示 next 版本信息# 百度分享, 不支持 httpsbaidushare: type: button 文章阅读次数统计/文章评论(LeanCloud) 配置leancloud, 获取 AppID 和 AppKey LeanCloud 创建 class Counter(文章阅读次数统计), Comment(文章评论) 配置next_config.yml12345678910111213141516171819202122# 文章阅读次数配置leancloud_visitors: enable: true app_id: leanclound AppID app_key: leanclound AppKey# 文章评论配置# 版本一: leancloud valine 版(不太好看, LeanCloud提供)# 需要安装 valine: npm install valine --save# https://valine.js.orgvaline: enable: true appid: leanclound AppID appkey: leanclound AppKey notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: 评论框为空的时候显示的内容# 版本二: hypercomments(简洁好用, 配置方便)# 需配置hypercomments得到id# http://blog.rmiao.top/2017/07/16/hexo-next-hypercomments/hypercomments_id: your hypercomments id 文章 Front-matter 配置1234567891011---title: "hexo + next 搭建个人博客" # 标题date: 2017-11-27 00:24:31 # 发布时间updated: # 更新日期comments: true # 是否开启文章评论tags: - hexo # 标签categories: - hexo # 分类type: # 类型 categories | tags--- 文章搜索(Local Search) 安装hexo-generator-searchdb, 站点根目录执行命令行npm install hexo-generator-searchdb --save 配置 hexo _config.yml 12345search: path: search.xml field: post format: html limit: 10000 配置 next _config.yml 1234local_search: enable: true trigger: auto # auto(搜索框内容改变就会进行搜索) | manual(按回车就进行搜索) top_n_per_article: 1 # 显示每篇每篇文章搜索到的前n个结果 其他hexo 标签数/分类数显示不一致 停止hexo hexo clean 启动hexo hexo-markdown-emoji渲染亲测会导致&lt;!-- more--&gt;失效emoji小抄链接 卸载hexo-renderer-markednpm uninstall hexo-renderer-marked --save 安装hexo-renderer-markdown-it, markdown-it-emojinpm install hexo-renderer-markdown-it --savenpm install markdown-it-emoji --save 配置hexo1234567markdown: plugins: - markdown-it-footnote - markdown-it-sup - markdown-it-sub - markdown-it-abbr - markdown-it-emoji # emoji渲染]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
